# 基本事項
- 常に英語で考えて、日本語で回答して。ですがコーディングはすべて英語で行って。
- タスク完了時にまずtestかbuildをして、それが通っていたら、絵文字付きのコミットメッセージを考えて git commitの実行を提案して
- 依頼に対して実行計画を立ててからコーディングをスタートして
- HonoによるAPIの実装はエンドポイントをすべてメソッドチェーンで記述し、クライアントでは必ずhc(Hono RPC Clientを利用して型安全にAPIを利用して)
- RemixとHonoの構成の場合は、HonoでSetしたCookieをRemixのloaderで返却するようにして。またRemixが受け取ったCookieやheaderは基本的にそのままHonoのhcに渡してHono側で利用できるようにして
- Honoのcrsfを有効にするためには、Remixのloaderでheaderを渡す必要があります(csrf)
- Honoは基本的には同じドメインからのアクセスのみを受け付けるようにします(cors)
- Honoは/api以下のみを管理
- 認証後はJWTを利用して更新処理を保護します
- RemixのloaderではgetUserを利用して認証が必要なページは保護します
- DBのスキーマのidは基本的にuuidv7のみを利用します（時系列情報を含む必要があります）。またPostgreSQLの場合はuuid型を必ず利用します
- process.envは使えません。Remixレイヤーではc.cloudflare.envを利用して環境変数を取得し、Honoレイヤーではc.envを利用して環境変数を取得します
- git diff等を確認する場合は、ページャーが発動することを防ぐためにgit --no-pager log や git --no-pager diffを利用してください
- Remixでレスポンスにjsonを使うのは非推奨なので見つけたら削除して
- データベースのテーブル名は基本的に複数形で命名して
- supabase/Postgresを利用している場合はRLSを利用してデータの保護を行ってください。ただし、drizzleは自動でRLSのスキーマからSQLを生成できないので、pnpm db:generate:blankを実行してから、からのsqlファイルの中身にRLSのSQLを記述してください
- gitで複数行のコミットメッセージが必要な場合は$ git commit -F- << EOMを利用してください

# DB, 特にsupabaseでRLSを利用する場合
1. **Postgresの接続の性質**:
- Direct Connection (port 5432) では、接続時にスーパーユーザー権限で接続されるため、単純な `role: 'anon'` の指定ではRLSが効きません
- Pooled Connection (port 6543) でも、単純なロール指定だけではRLSのコンテキストが正しく設定されません

2. **正しいアプローチ**:
```typescript
// 1. Pooled Connection URLを使用
const client = postgres(process.env.DATABASE_URL, {
  prepare: false  // プール接続では必須
});

const db = drizzle(client);

// 2. トランザクション内でロールとコンテキストを設定
export const rlsQuery = async <T>(
  userId: string | null,  // nullの場合はanon
  txFunc: QueryInTransaction<T>
) => {
  return await db.transaction(async (tx) => {
    if (userId) {
      // authenticated ユーザーの場合
      await tx.execute(sql`
        set session role authenticated;
        select set_config('request.jwt.claim.sub', ${userId}, true);
      `);
    } else {
      // anon ユーザーの場合
      await tx.execute(sql`set session role anon;`);
    }

    return await txFunc(tx);
  });
};
```

3. **使用例**:
```typescript
// 匿名ユーザーとしてのクエリ
const publicPosts = await rlsQuery(null, async (tx) => {
  return await tx.select().from(posts).where(eq(posts.is_public, true));
});

// 認証済みユーザーとしてのクエリ
const userPosts = await rlsQuery(userId, async (tx) => {
  return await tx.select().from(posts);
});
```
